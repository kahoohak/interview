## 浏览器安全<br>

1. 什么是 XSS 攻击？<br>
XSS攻击指的是跨站脚本攻击，攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户信息<br>
分为三种类型<br>
存储型：恶意脚本会存储在服务器上，当浏览器请求数据时，脚本从服务器传回并执行<br>
反射型；攻击者将恶意代码藏在url中，诱导用户点击，服务器再将恶意脚本拼接在html中返回<br>
DOM型：与反射型类似，但是是前端来取出和执行恶意脚本<br>

2. 如何防御 XSS 攻击？<br>
可以从浏览器的执行来预防，使用纯前端，不用服务器拼接后返回，另一种是对即将要插入html的代码做好转义<br>
使用CSP，相当于设置一个脚本执行的白名单，可以通过http首部设置CSP，也可以meta标签设置<br>
对一些敏感信息保护，例如cookie设置http-only，防止脚本被获取。也可以使用验证码，防止攻击者假冒用户窃取信息<br>

3. 什么是 CSRF 攻击？<br>
CSRF指的是跨站请求伪造攻击，本质就是利用cookie会在同源请求中携带发送给服务器的特点，实现冒充用户<br>
有三种攻击类型：<br>
get类型，post类型，链接类型<br>

4. 如何防御 CSRF 攻击？<br>
进行同源检测：通过判断请求头中origin和referer是否为允许访问的站点，不是直接拒绝，但是referer是可以被伪造的，同时也会屏蔽搜索引擎链接<br>
使用CSRF token进行验证：服务端给客户端一个随机数token，客户端每次请求时带上token来验证<br>
对cookie进行双重验证：服务端向客户端注入一个cookie，客户端在下次请求时取出cookie拼接在url上，供服务端比对cookie和参数来验证，因为攻击者只能利用cookie，无法获取cookie，缺点是网站如果存在xss漏洞，该方式无效<br>
cookie设置Samesite，限制cookie不能被第三方使用：推荐使用<br>

5. 什么是中间人攻击？如何防范中间人攻击？<br>
指攻击者同时建立与通讯两端的连接，整个会话都被中间人控制<br>
攻击过程：<br>
客户端发起请求，请求被中间人截获<br>
服务端发送公钥<br>
中间人截取公钥，向客户端发送自己创建的假公钥<br>
客户端收到假公钥，并生成加密hash发送给服务器<br>
中间人收到加密hash，解密出秘钥，再用之前的服务器公钥生成加密hash给服务端<br>
服务端解密出秘钥，开始用秘钥传输数据，此时中间人已经完全控制会话<br>

6. 有哪些可能引起前端安全的问题**?**<br>
跨站脚本XSS<br>
跨站点请求伪造CSRF<br>
iframe滥用<br>
恶意第三方库<br>

7. 网络劫持有哪几种，如何防范？<br>
DNS劫持<br>
http劫持<br>
DNS劫持现在被监管，很少发生了，http劫持可以升级https来解决<br>

## 进程与线程<br>

1. 进程与线程的概念<br>
进程代表了一个程序，线程是进程中的更小单位<br>
进程是资源分配的最小单位，线程是cpu调度的最小单位<br>

2. 进程和线程的区别<br>
进程可以看做独立应用，线程不能<br>
进程是资源分配的最小单位，线程是cpu调度的最小单位<br>
线程可以共享同一进程中的资源，进程间不可以直接共享<br>
进程切换，创建和销毁的开销比线程大<br>

3. 浏览器渲染进程的线程有哪些<br>
GUI渲染线程：<br>
负责渲染浏览器页面，解析html，css，构建dom树，cssom树，构建渲染树和绘制页面，当页面重绘回流，该线程会执行，与js引擎线程互斥<br>
JS引擎线程：<br>
负责处理js脚本，与GUI渲染线程互斥<br>
事件触发线程：<br>
属于浏览器，用来控制时间循环，当遇到setTimeout，异步请求等等，会将对应任务添加到事件触发线程中，当任务被触发时，该线程会把任务添加到待处理队列，等待js引擎处理<br>
定时器触发线程：<br>
即setInterval和setTimeout所在线程，因为js引擎是单线程，所以使用单独线程来计数，计数完毕，添加到事件队列中<br>
异步http请求线程：<br>
xhr连接后通过浏览器新开了一个请求线程，检测到状态变更时，如果有回调，会放入事件队列中，等待js引擎线程执行<br>

4. 进程之前的通信方式---了解即可<br>
5. 僵尸进程和孤儿进程是什么？---了解即可（或者不需要看）<br>
6. 死锁产生的原因？ 如果解决死锁的问题？---了解即可（或者不需要看）<br>
7. 如何实现浏览器内多个标签页之间的通信?<br>
本质上都是通过中介者模式来实现<br>
使用socket协议<br>
使用localStorage<br>
使用postMessage<br>
使用sharedWorker<br>

8. 对Service Worker的理解<br>
service worker是运行在浏览器背后的独立线程，一般可用来实现缓存。使用serviceworker，传输协议必须是https，因为涉及到请求拦截，必须使用https保证安全<br>
首先注册service worker<br>
监听install事件来缓存需要的文件<br>
下次用户访问时，通过拦截请求查询是否存在缓存，存在直接读取缓存，否则请求数据<br>

## 浏览器缓存<br>

1. 对浏览器的缓存机制的理解<br>
浏览器第一次加载资源，会缓存资源文件与response header，供下次比对<br>
下次加载时，首先命中强制缓存，会算当前时间与上次请求的时间差，与cache-control的max-age比较，如果比它小，则走强制缓存，从本地加载资源，如果不支持http1.1，则通过expires比较是否过期<br>
未命中强制缓存，则走协商缓存，发送一个携带If-None-Match和If-Modified-Since的请求，服务器首先比较资源文件的Etag和If-None-Match是否匹配，不一致返回304，走本地资源，一致返回新资源和新Etag，状态码200（注意是If-None-Match，If-Match是反过来的）<br>
如果服务端没有Etag，则比较If-Modified-Since和资源文件的最后修改时间是否一致，一致返回304，不一致返回新资源和新Last-Modified，状态码200<br>

2. 浏览器资源缓存的位置有哪些？<br>
Service Worker：运行在主线程之外，可以完成离线缓存，消息推送等功能，并且是持续性缓存<br>
Memory Cache：内存缓存，读取效率最高，但是持续性很短，进程关闭即释放<br>
Disk Cache：硬盘缓存，容量大，时效性长，它根据http header判断哪些需要被缓存<br>

3. 协商缓存和强缓存的区别<br>
两者命中时都会使用本地缓存，但是协商缓存会多发送一次请求<br>
两者是配合使用的，先走强缓存，未命中才会再走协商缓存<br>

4. 为什么需要浏览器缓存？<br>
减少服务器负担，提高了网站性能<br>
加快客户端网页加载速度<br>
减少冗余的网络传输<br>

5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？<br>
点击刷新或者按F5，跳过强制缓存，但是会走协商缓存<br>
Ctrl+F5强制刷新，不走任何缓存<br>
地址栏回车：正常请求<br>

## 浏览器组成<br>

1. 对浏览器的理解<br>
浏览器分为外壳和内核，外壳指菜单工具栏等，给用户使用的，内核是基于标记语言显示内容的程序<br>

2. 对浏览器内核的理解<br>
渲染引擎：职责就是在窗口渲染显示的内容<br>
js引擎：解析和执行JavaScript<br>
随着js引擎越来越独立，浏览器内核多指渲染引擎<br>

3. 常见的浏览器内核比较<br>
Trident：ie使用，俗称IE内核<br>
Gecko：FireFox使用，统称FireFox内核<br>
Presto：Opera曾使用，现在使用Blink<br>
Webkit：Safari使用<br>
Blink：Google使用，统称Google内核<br>

4. 常见浏览器所用内核---了解即可<br>
5. 浏览器的主要组成部分<br>
用户界面<br>
浏览器引擎<br>
呈现引擎<br>
网络<br>
用户界面后端<br>
JavaScript解释器<br>
数据存储<br>

## 浏览器渲染原理<br>

1. 浏览器的渲染过程<br>
解析html构建DOM树<br>
解析css构建CSSOM树<br>
根据DOM树和CSSOM树构建渲染树，渲染树的节点称为渲染对象<br>
当渲染对象插入渲染树时，他们并没有位置，渲染树需要进行布局，也称为回流<br>
布局阶段结束，进入绘制阶段，遍历渲染树将它们的内容显示在屏幕上<br>
这个过程是逐步完成的，渲染引擎为了更好地用户体验，并不会等待所有html解析完再绘制，而是解析一部分就渲染一部分，同时还可以通过下载其余内容<br>

2. 浏览器渲染优化<br>
针对JavaScript：<br>
尽量将js脚本放在body后加载，因为js会阻塞html和css的解析<br>
script：立即停止页面渲染去加载js，加载完成立即执行，执行完才会继续渲染<br>
aync：异步加载，加载完立即执行，多个async脚本不会顺序执行<br>
defer：异步加载，加载完会等待文档加载完再执行，多个defer脚本按顺序执行<br>
针对css：<br>
link：浏览器开启http线程去请求资源，不会阻塞GUI渲染<br>
@import：GUI线程去请求资源，会阻塞渲染<br>
style：GUI直接渲染<br>
样式一般写在head中，保证尽快渲染页面<br>
外部文件一般使用link，如果css少，推荐使用内联<br>
针对DOM树，CSSOM树：<br>
html代码层级尽量不要太深<br>
使用语义化标签<br>
减少css代码层级，因为css是从右到左解析的<br>
减少回流与重绘：<br>
操作DOM时，尽量在低层级的节点操作<br>
不要使用table布局，一个小改动可能会使table重新布局<br>
不要频繁操作元素样式，尽量使用类名切换<br>
使用absolute或者fixed，这样元素会脱离文档流，这样它们发生变化不会影响其他元素<br>
避免频繁操作DOM，可以创建documentFragment，在文档片段上应用DOM操作再插入<br>
把元素设置为display：none，再进行DOM操作完再显示，因为不显示的元素不会触发回流和重绘<br>
将DOM的多个读操作/写操作合并在一起，而不是穿插在一起写<br>

3. 渲染过程中遇到 JS 文件如何处理？<br>
遇到js文件会阻塞渲染执行，可以吧js文件放在body后面，或者添加async，defer属性<br>

4. 什么是文档的预解析？<br>
当执行js脚本时，另一个线程去解析剩下的文档，并加载后面需要通过网络加载的资源<br>
预解析并不改变DOM树，只解析外部资源的引用<br>

5. CSS 如何阻塞文档解析？<br>
如果浏览器尚未完成CSSOM树的构建，我们却想在此时执行js脚本，浏览器将延迟脚本执行和文档解析，直至其完成CSSOM树的构建<br>

6. 如何优化关键渲染路径？<br>
7. 什么情况会阻塞渲染？<br>
渲染前提是生成渲染树，html和css文件过大会导致阻塞，解析到script标签时，会阻塞渲染，script标签需要放在body后或者加上async/defer属性<br>

## 浏览器本地存储<br>
1. 浏览器本地存储方式及使用场景<br>
2. Cookie有哪些字段，作用分别是什么<br>
3. Cookie、LocalStorage、SessionStorage区别<br>
4. 前端储存的⽅式有哪些？<br>
5. IndexedDB有哪些特点？---了解即可<br>

## 浏览器同源策略<br>
1. 什么是同源策略<br>
2. 如何解决跨越问题<br>
3. 正向代理和反向代理的区别---了解即可<br>
4. Nginx的概念及其工作原理---了解即可（或者不需要看）<br>

## 浏览器事件机制<br>
1. 事件是什么？事件模型？<br>
2. 如何阻止事件冒泡<br>
3. 对事件委托的理解<br>
4. 事件委托的使用场景<br>
5. 同步和异步的区别<br>
6. 对事件循环的理解<br>
7. 宏任务和微任务分别有哪些<br>
8. 什么是执行栈<br>
9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？<br>
10. 事件触发的过程是怎样的<br>

## 浏览器垃圾回收机制---了解即可<br>

1. V8的垃圾回收机制是怎样的<br>
2. 哪些操作会造成内存泄漏？<br>