## HTTP协议

1. GET和POST的请求的区别<br>
幂等：<br>
get是幂等的，一般用于请求不会对服务器资源造成影响的场景<br>
post是非幂等的，一般请求会对服务器资源造成影响的场景，如注册用户<br>
缓存：<br>
浏览器一般会对get请求缓存，post不会<br>
报文格式：<br>
get报文实体为空，post报文实体是要发送的数据<br>
安全性：<br>
get请求的参数会在拼接在url上，安全性稍差<br>
请求长度：<br>
浏览器对于get请求的url长度会有限制<br>
参数类型：<br>
post请求会支持更多参数类型<br>

2. POST和PUT请求的区别<br>
put会修改内容，但不会改变内容的类型，可以理解为更新数据<br>
post会改变内容的类型，可以理解为创建数据<br>

3. 常见的HTTP请求头和响应头<br>
request header:<br>
Accept, Accept-Chartset, Accept-Encoding, Accept-language, Connection, Cookie, Host, Referer, User-Agent<br>
response header:<br>
Date, Server, Connection, Cache-Control, Content-Type<br>

4. HTTP状态码304是多好还是少好<br>
304代表当前资源会走协商缓存<br>
产生较多304的原因：<br>
页面长期不更新，纯静态页面<br>
过多304的缺点：<br>
网站快照停止，收录减少，权重下降<br>

5. 常见的HTTP请求方法<br>
get, post, put, delete, options, head<br>

6. OPTIONS请求方法及使用场景<br>
使用场景：<br>
获取服务器支持的所有请求方法<br>
检查访问权限，在进行cors跨域资源共享时，会先发送options嗅探请求，以判断是否有访问权限<br>

7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？<br>
连接：<br>
1.0默认使用非持久连接，1.1使用持久连接，1.1可以复用tcp连接，避免了每次重新连接的耗时<br>
资源请求：<br>
当用户只需要对象的某一部分时，1.0会返回整个对象，会浪费带宽，1.1增加了range头域，允许请求资源的某一部分<br>
缓存：<br>
1.0主要使用If-Modified-Since, Expires，1.0引入了更多的缓存策略，If-Unmodified-Since, If-Match, If-None-Match, Etag<br>
1.1新增了host，用来指定服务器的域名<br>
1.1新增了put，delete，head，options等请求方法<br>

8. HTTP 1.1 和 HTTP 2.0 的区别<br>
二进制协议：<br>
1.1中，头部信息必须是文本，数据可以是文本或者二进制<br>
2.0头部信息和数据体都是二进制<br>
多路复用：<br>
2.0仍然复用了tcp连接，客户端和服务端可以同时发送多个请求和响应，而且不必一一按照顺序发送，这就避免了队头堵塞的问题<br>
（队头堵塞：http规定请求必须是一发一收，这就形成了一个先进先出的请求队列，前一个请求如果耗时过长，会导致后面的请求一直得不到响应，这就是队头堵塞）<br>
数据流：<br>
2.0使用了数据流的概念，2.0因为数据包不是按照顺序发送的，同一个连接里连续的数据包，可能属于不同的请求，所以数据包需要标记对应哪个请求<br>
每个请求或者相应的所有数据包称为数据流，数据流有专属的编号作为数据流id，id来作为标识<br>
头信息压缩：<br>
由于1.1协议不带状态，所以每次请求都必须带上头部信息，很多字段都是重复的，会浪费带宽<br>
2.0引入了头信息压缩机制，一方面，头部信息使用gzip或者compress压缩，另一方面，客户端和服务端会维护一张头部信息表，生成一个索引号，以后只发送索引号，这样就减少了带宽，提升速度<br>
服务器推送：<br>
2.0允许服务器主动向客户端发送资源，这叫做服务器推送，服务器提前给客户端推送必要的资源，这样就减少了延迟时间<br>
需要注意的是2.0推送的是静态资源，并不像webSocket那种推送的即时消息<br>

9. HTTP和HTTPS协议的区别<br>
https需要CA证书，且费用较高，https不需要<br>
http是超文本传输协议，信息是明文传输的，https是具有安全性的SSL加密传输协议<br>
端口不同，http是80，https是443<br>
http连接是无状态的，https是由SSL和http协议构建的可以进行加密传输，身份认证的网络协议，比http更安全<br>

10. GET方法URL长度限制的原因<br>
这是浏览器对url的限制<br>

11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？<br>
解析url<br>
检查缓存<br>
dns解析<br>
获取主机MAC地址<br>
tcp三次握手<br>
https握手<br>
返回数据<br>
页面渲染<br>
tcp四次挥手<br>

12. 对keep-alive的理解---了解即可<br>
13. 页面有多张图片，HTTP是怎样的加载表现？<br>
http1: 浏览器对一个域名下最大tcp连接数是6，所以会请求多次，可以用多域名部署解决。<br>
http2: 可以瞬间加载很多资源，因为http2实现了多路复用，可以在一个tcp连接发送多个请求<br>

14. HTTP2的头部压缩算法是怎样的？---了解即可<br>
15. HTTP请求报文的是什么样的？<br>
请求行，请求头部，空行，请求体<br>
请求行：请求方法，url，http协议版本<br>
请求头部：User-agent, host, Accept<br>
请求体：post，put等携带的数据<br>

16. HTTP响应报文的是什么样的？<br>
响应行，响应头部，空行，响应体<br>
响应行：由网络协议版本，状态码和状态码的原因短语组成，如http1.1 200 OK<br>
响应头部：响应部首组成，如content-type，content-length，date等<br>
响应体：服务器相应的数据<br>

17. HTTP协议的优点和缺点<br>
优点：<br>
简单快速：每次请求只需传送请求方法和路径<br>
无连接：每次只处理一个请求，完成请求断开连接，节省了传输时间<br>
无状态：服务器不会保存通信过程中的上下文信息，在服务器不需要先前信息时应答会很快<br>
灵活：允许传输任意类型的数据对象<br>
缺点：<br>
无状态：因为服务器不会保存通信过程中的上下文信息，所以服务器如果需要信息，都必须重新传输，导致数据量增大<br>
明文传输：协议中的报文使用的文本形式，会暴露给外界，不安全<br>

18. 说一下HTTP 3.0<br>
http3.0基于UDP协议实现了类似TCP多路复用数据流，传输可靠性等功能，这套功能被称为QUIC协议<br>

19. HTTP协议的性能怎么样 ---了解即可<br>
20. URL有哪些组成部分<br>
协议，域名，端口，虚拟目录，文件名，锚，参数<br>

21. 与缓存相关的HTTP请求头有哪些<br>
强缓存：<br>
Expires<br>
Cache-Control<br>
协商缓存：<br>
E-tag<br>
If-None-Match<br>
Last-Modified<br>
If-Modified-Since<br>

## HTTPS协议<br>

1. 什么是HTTPS协议？<br>
超文本传输安全协议是一种通过计算机网络进行安全通信的网络协议<br>
https经由http进行通信，利用ssl/tls加密数据包，主要目的是提供对服务器的身份认证，保证交换数据的隐私和完整性<br>

2. TLS/SSL的工作原理<br>
散列函数hash：md5加密<br>
对称加密：服务端和客户端使用同一个秘钥解密数据，但是无法保证秘钥的安全性<br>
非对称加密：服务端和客户端使用公钥和私钥来加密解密<br>

3. 数字证书是什么？<br>
使用非对称加密和对称加密无法保证公钥不会被截取，数字证书就是为了解决这个问题<br>
首先使用一种hash算法对服务端的公钥和信息加密生成信息摘要，第三方机构再用机构私钥对摘要加密，生成签名，签名和原始信息合在一起成为数字证书<br>
接收方收到证书时，先根据原始信息使用相同的hash算法生成信息摘要，再用机构的公钥解密出证书里的摘要，两者进行比对，如果一致则证明信息没有被更改 再解密出服务端的公钥就可以通信了<br>

4. HTTPS通信（握手）过程<br>
客户端向服务端发起请求：包含了随机数和加密方法<br>
服务器接收到请求后，确认加密方法，给出随机数和证书<br>
客户端确认证书有效后，生成一个新的随机数，并用证书中的公钥加密，然后发给服务器，并且还会提供前面所有内容的hash供校验<br>
服务端使用自己的私钥解密，得到新随机数，并返回前面所有内容的hash供客户端校验<br>
客户端和服务端使用约定的加密方法对三个随机数加密作为秘钥，之后的通信就使用这个秘钥<br>

5. HTTPS的特点<br>
优点：<br>
可以认证用户和服务器，进行加密传输，确保数据不会被拦截和篡改，保证了数据传输的安全性<br>
缺点：<br>
服务端和客户端的加密解密耗费服务器资源<br>
握手阶段比较耗时<br>
费用昂贵<br>
ssl证书需要绑定ip，不能在一个ip绑定多个域名<br>

6. HTTPS是如何保证安全的？<br>
使用对称加密和非对称加密，用非对称加密的公钥来加密对称加密的秘钥，接收方再使用私钥来解密出对称加密的秘钥，双方就可以使用秘钥来通信了<br>
但此时仍不安全，无法确保公钥不会被拦截<br>
所以加入了第三方机构CA，CA提供了数字签名和证书<br>
数字签名就是对原始信息使用CA的hash算法生成摘要，再用CA私钥加密出来的就是数字签名，客户端接收到证书，使用CA公钥解密出摘要，再使用同样的hash算法对证书中的原始信息生成摘要，两者对比就知道是否被黑客篡改过了，大大保证了安全<br>

# HTTP状态码<br>

1. 2XX (Success 成功状态码)<br>
200 请求成功<br>
2. 3XX (Redirection 重定向状态码)<br>
301 永久重定向<br>
302 临时重定向<br>
304 协商缓存<br>

3. 4XX (Client Error 客户端错误状态码)<br>
400 请求报文存在语法错误<br>
403 访问被服务器拒绝<br>
404 资源未找到<br>

4. 5XX (Server Error 服务器错误状态码)---了解即可<br>
500 服务器在执行请求时发生了错误<br>
503 服务器维护<br>
504 服务器无法响应<br>

5. 总结<br>

# DNS协议介绍---了解即可<br>

1. DNS 协议是什么<br>
2. DNS同时使用TCP和UDP协议？<br>
3. DNS完整的查询过程<br>
4. 迭代查询与递归查询<br>
5. DNS 记录和报文<br>

# 网络模型---了解即可<br>

1. OSI七层模型<br>
应用层，表示层，会话层，传输层，网络层，数据链路层，物理层<br>
tcp和udp都是传输层协议，http属于应用层<br>
<br>
2. TCP/IP五层协议<br>

# TCP与UDP---了解即可<br>

1. TCP 和 UDP的概念及特点<br>
2. TCP和UDP的区别<br>
3. TCP和UDP的使用场景<br>
4. UDP协议为什么不可靠？<br>
5. TCP的重传机制<br>
6. TCP的拥塞控制机制<br>
7. TCP的流量控制机制<br>
8. TCP的可靠传输机制<br>

9. TCP的三次握手和四次挥手---了解即可<br>
第一次握手 客户端发起，携带SYN=1， ACK=0，seq=x<br>
第二次握手 服务端发起，携带SYN=1，ACK=1，ack=x+1，seq=y<br>
第三次握手 客户端发起，携带ACK=1，ack=y+1，seq=x+1<br>
三次握手才能确认双方都具备发送和接收的能力<br>
第一次挥手 客户端发起，携带FIN=1，ACK=0，seq=x<br>
第二次挥手 服务端发起，携带ACK=1，ack=x+1，seq=y<br>
第三次挥手 服务端发起，携带FIN=1，ACK=1，ack=x+1，seq=z<br>
第四次挥手 客户端发起，携带ACK=1，ack=z+1，seq=x+1<br>
因为tcp连接是双方的，需要双方的释放和确认，只一方释放，连接处于半释放的状态<br>
第二次挥手结束，双方只是确认了结束连接这件事，服务端可能还有未发完的消息，等消息发完，服务端才会开启第三次挥手<br>

10. TCP粘包是怎么回事，如何处理**?** ---了解即可（或者不需要看）<br>
11. 为什么udp不会粘包？ ---了解即可（或者不需要看）<br>

# WebSocket<br>

1. 对 WebSocket 的理解<br>
webSocket一种全双工的通讯技术，属于应用层协议，它基于tcp传输协议，它最大的特点是客户端和服务端只需要一次握手，就可以创建持久性的连接，客户端和服务端都可以主动发消息，实现双向通信<br>
<br>
2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？---了解即可<br>

